<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Envelope Morph Visualizer</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
    }
    canvas {
      background: #000;
      border: 1px solid #333;
      border-radius: 8px;
      width: 90%;
      max-width: 800px;
      height: 300px;
    }
    input[type=range] {
      width: 80%;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="800" height="300"></canvas>
  <input id="morph" type="range" min="0" max="10000" value="0" />
  <div id="label">Morph: 0</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const morphSlider = document.getElementById('morph');
    const label = document.getElementById('label');

    function mix(a, b, t) { return a * (1 - t) + b * t; }

    // Master envelope function that blends multiple shape zones
    function envelope(x, morph) {
      const t = morph; // normalized 0–1
      // Segment-based morphing between several shape families
      if (t < 0.2) {
        // Exponential decay zone
        const k = mix(5, 50, t / 0.2);
        return Math.exp(-k * x);
      } else if (t < 0.4) {
        // Power-law / slope transition
        const p = mix(1.5, 6, (t - 0.2) / 0.2);
        return Math.pow(1 - x, p);
      } else if (t < 0.6) {
        // Inverse / smooth bend
        const p = mix(1, 8, (t - 0.4) / 0.2);
        return 1 / (1 + Math.pow(x * 4, p));
      } else if (t < 0.8) {
        // Bouncy / rubbery
        const d = mix(2, 8, (t - 0.6) / 0.2);
        return Math.abs(Math.sin((1 - x) * Math.PI * mix(1, 3, (t - 0.6) / 0.2))) * Math.exp(-d * x);
      } else {
        // Glitchy tail / chaos
        const f = mix(10, 80, (t - 0.8) / 0.2);
        const g = Math.sin(f * x) * 0.2;
        return Math.max(0, Math.min(1, Math.exp(-8 * x) + g));
      }
    }

    function drawEnvelope(morphValue) {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.beginPath();
      const steps = 512;
      const morph = morphValue / 10000; // normalize 0–1
      for (let i = 0; i <= steps; i++) {
        const x = i / steps;
        const y = envelope(x, morph);
        const px = x * w;
        const py = h - y * h;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    morphSlider.addEventListener('input', () => {
      const v = parseFloat(morphSlider.value);
      label.textContent = `Morph: ${v}`;
      drawEnvelope(v);
    });

    drawEnvelope(0);
  </script>
</body>
</html>
