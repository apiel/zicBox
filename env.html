<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Smooth Envelope Morph Visualizer (Perfect Continuity)</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
  }
  canvas {
    background: #000;
    border: 1px solid #333;
    border-radius: 8px;
    width: 90%;
    max-width: 800px;
    height: 300px;
  }
  input[type=range] {
    width: 80%;
    margin-top: 20px;
  }
</style>
</head>
<body>
  <canvas id="canvas" width="800" height="300"></canvas>
  <input id="morph" type="range" min="0" max="10000" value="0" />
  <div id="label">Morph: 0</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const morphSlider = document.getElementById('morph');
    const label = document.getElementById('label');

    const smoothstep = (a, b, x) => {
      const t = Math.max(0, Math.min(1, (x - a) / (b - a)));
      return t * t * (3 - 2 * t);
    };
    const mix = (a, b, t) => a * (1 - t) + b * t;

    // Base shape families
    const shapeExp = (x, sharp) => Math.exp(-sharp * x);
    const shapePow = (x, p) => Math.pow(1 - x, p);
    const shapeInverse = (x, p) => 1 / (1 + Math.pow(x * 4, p));
    const shapeBounce = (x, f, d) => Math.abs(Math.sin((1 - x) * Math.PI * f)) * Math.exp(-d * x);
    const shapeGlitch = (x, f, a) => Math.max(0, Math.min(1, Math.exp(-8*x) + Math.sin(f*x)*a));

    function envelope(x, morph) {
      // normalize & avoid hard 1.0
      const m = Math.min(0.9999, Math.pow(morph, 1.2));
      // asymmetric blend zones
      const zones = [0.0, 0.45, 0.6, 0.75, 1.0];
      const z = zones.findIndex(z => m < z) - 1;
      const idx = Math.max(0, z);
      const prev = zones[idx];
      const next = zones[idx+1] ?? 1.0;
      const f = smoothstep(prev, next, m);

      const e1 = shapeExp(x, 5 + Math.pow(1 - morph, 4) * 150);
      const e2 = shapePow(x, 1.5 + morph * 5);
      const e3 = shapeInverse(x, 1 + morph * 8);
      const e4 = shapeBounce(x, 1 + morph * 2, 2 + morph * 6);
      const e5 = shapeGlitch(x, 10 + morph * 70, 0.1 + morph * 0.1);

      const shapes = [e1, e2, e3, e4, e5];
      // blend to final shape smoothly even at max
      return mix(shapes[idx], shapes[idx+1] ?? shapes[idx], f);
    }

    function drawEnvelope(morphValue) {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.beginPath();
      const steps = 512;
      const morph = morphValue / 10000;
      for (let i = 0; i <= steps; i++) {
        const x = i / steps;
        const y = envelope(x, morph);
        const px = x * w;
        const py = h - y * h;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    morphSlider.addEventListener('input', () => {
      const v = parseFloat(morphSlider.value);
      label.textContent = `Morph: ${v}`;
      drawEnvelope(v);
    });

    drawEnvelope(0);
  </script>
</body>
</html>
